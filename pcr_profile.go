// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2019 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package secboot

import (
	"bytes"
	"errors"
	"fmt"

	"github.com/canonical/go-tpm2"

	"golang.org/x/xerrors"
)

// pcrValuesList is a list of PCR value combinations computed from PCRProtectionProfile.
type pcrValuesList []tpm2.PCRValues

// setValue sets the specified PCR to the supplied value for all branches.
func (l pcrValuesList) setValue(alg tpm2.HashAlgorithmId, pcr int, value tpm2.Digest) {
	for _, v := range l {
		v.SetValue(alg, pcr, value)
	}
}

// extendValue extends the specified PCR with the supplied value for all branches.
func (l pcrValuesList) extendValue(alg tpm2.HashAlgorithmId, pcr int, value tpm2.Digest) {
	for _, v := range l {
		if _, ok := v[alg]; !ok {
			v[alg] = make(map[int]tpm2.Digest)
		}
		if _, ok := v[alg][pcr]; !ok {
			v[alg][pcr] = make(tpm2.Digest, alg.Size())
		}
		h := alg.NewHash()
		h.Write(v[alg][pcr])
		h.Write(value)
		v[alg][pcr] = h.Sum(nil)
	}
}

func (l pcrValuesList) copy() (out pcrValuesList) {
	for _, v := range l {
		ov := make(tpm2.PCRValues)
		for alg := range v {
			ov[alg] = make(map[int]tpm2.Digest)
			for pcr := range v[alg] {
				ov[alg][pcr] = v[alg][pcr]
			}
		}
		out = append(out, ov)
	}
	return
}

type pcrProtectionProfileAddPCRValueInstr struct {
	alg   tpm2.HashAlgorithmId
	pcr   int
	value tpm2.Digest
}

type pcrProtectionProfileAddPCRValueFromTPMInstr struct {
	alg tpm2.HashAlgorithmId
	pcr int
}

type pcrProtectionProfileExtendPCRInstr struct {
	alg   tpm2.HashAlgorithmId
	pcr   int
	value tpm2.Digest
}

type pcrProtectionProfileAddBranchesInstr struct {
	profiles []*PCRProtectionProfile
}

type pcrProtectionProfileEndBranchInstr struct{}

// pcrProtectionProfileInstr is a building block of PCRProtectionProfile.
type pcrProtectionProfileInstr interface{}

// PCRProtectionProfile defines the PCR profile used to protect a key sealed with SealKeyToTPM. It contains a sequence of instructions
// for computing combinations of PCR values that a key will be protected against. The profile is built using the methods of this type.
type PCRProtectionProfile struct {
	builder *PCRProtectionProfileBranchBuilder
	instrs  []pcrProtectionProfileInstr
}

// PCRProtectionProfileBranchBuilder provides a mechanism to build branches in a PCR profile using chains of function calls. It is
// created by PCRProtectionProfile.BeginBranchPoint.
type PCRProtectionProfileBranchBuilder struct {
	parent         *PCRProtectionProfile
	parentInstrLen int
	profiles       []*PCRProtectionProfile
}

func NewPCRProtectionProfile() *PCRProtectionProfile {
	return &PCRProtectionProfile{}
}

// AddPCRValue adds the supplied value to this profile for the specified PCR. This action replaces any value set previously in this
// profile. The function returns the same PCRProtectionProfile so that calls may be chained.
func (p *PCRProtectionProfile) AddPCRValue(alg tpm2.HashAlgorithmId, pcr int, value tpm2.Digest) *PCRProtectionProfile {
	if len(value) != alg.Size() {
		panic("invalid digest length")
	}
	p.instrs = append(p.instrs, &pcrProtectionProfileAddPCRValueInstr{alg: alg, pcr: pcr, value: value})
	return p
}

// AddPCRValueFromTPM adds the current value of the specified PCR to this profile. This action replaces any value set previously in
// this profile. The current value is read back from the TPM when the PCR values generated by this profile are computed. The function
// returns the same PCRProtectionProfile so that calls may be chained.
func (p *PCRProtectionProfile) AddPCRValueFromTPM(alg tpm2.HashAlgorithmId, pcr int) *PCRProtectionProfile {
	p.instrs = append(p.instrs, &pcrProtectionProfileAddPCRValueFromTPMInstr{alg: alg, pcr: pcr})
	return p
}

// ExtendPCR extends the value of the specified PCR in this profile with the supplied value. If this profile doesn't yet have a
// value for the specified PCR, an initial value of all zeroes will be added first. The function returns the same PCRProtectionProfile
// so that calls may be chained.
func (p *PCRProtectionProfile) ExtendPCR(alg tpm2.HashAlgorithmId, pcr int, value tpm2.Digest) *PCRProtectionProfile {
	if len(value) != alg.Size() {
		panic("invalid digest length")
	}
	p.instrs = append(p.instrs, &pcrProtectionProfileExtendPCRInstr{alg: alg, pcr: pcr, value: value})
	return p
}

// AddBranches adds one or branches that can be used to define PCR policies for multiple conditions. Note that the sub-profile for
// each branch must explicitly define values for the same set of PCRs. It is not possible to generate policies where each branch
// defines values for a different set of PCRs. When computing the PCR values for this profile, the sub-profiles added by this command
// will inherit the PCR values computed by this profile. The function returns the same PCRProtectionProfile so that calls may be
// chained.
func (p *PCRProtectionProfile) AddBranches(profiles ...*PCRProtectionProfile) *PCRProtectionProfile {
	p.instrs = append(p.instrs, &pcrProtectionProfileAddBranchesInstr{profiles: profiles})
	return p
}

// BeginBranchPoint returns a new PCRProtectionProfileBranchBuilder which allows multiple branches to be added to this PCR profile
// using chains of function calls. Once the branches have been created, they are inserted in to this profile by calling
// PCRProtectionProfileBranchBuilder.FinishBranchPoint.
func (p *PCRProtectionProfile) BeginBranchPoint() *PCRProtectionProfileBranchBuilder {
	return &PCRProtectionProfileBranchBuilder{parent: p, parentInstrLen: len(p.instrs)}
}

// ExitBranch completes the branch associated with this profile and returns the original PCRProtectionProfileBranchBuilder so that
// further branches can be started, or so that insertion of branches in to the parent profile can be completed.
//
// If this PCRProtectionProfile was not created from a call to PCRProtectionProfileBranchBuilder.EnterBranch, then this function
// will panic.
func (p *PCRProtectionProfile) ExitBranch() *PCRProtectionProfileBranchBuilder {
	if p.builder == nil {
		panic("ExitBranch called more than once or on a profile that wasn't created from PCRProtectionProfileBranchBuilder")
	}
	if p.builder.parent == nil {
		panic("PCRProtectionProfileBranchBuilder.EndBranches already called")
	}
	p.builder.profiles = append(p.builder.profiles, p)
	b := p.builder
	p.builder = nil
	return b
}

// EnterBranch returns a new PCRProtectionProfile so that a sub-branch can be created which will be added to the parent PCR profile
// when PCRProtectionProfileBranchBuilder.FinishBranchPoint is called. The caller eventually signals that this branch is completed
// by calling PCRProtectionProfile.ExitBranch.
func (b *PCRProtectionProfileBranchBuilder) EnterBranch() *PCRProtectionProfile {
	return &PCRProtectionProfile{builder: b}
}

// FinishBranchPoint signals that all branches have been created. It adds the created branches to the parent PCR profile using
// PCRProtectionProfile.AddBranches and then returns the parent profile so that further instructions can be added to it.
//
// This function will panic if it is called more than once, or if instructions were added to the parent PCRProtectionProfile since
// the call to PCRProtectionProfile.BeginBranchPoint.
func (b *PCRProtectionProfileBranchBuilder) FinishBranchPoint() *PCRProtectionProfile {
	if b.parent == nil {
		panic("EndBranches called more than once")
	}
	if len(b.parent.instrs) != b.parentInstrLen {
		panic("commands added to the parent sequence")
	}
	p := b.parent
	b.parent = nil
	return p.AddBranches(b.profiles...)
}

// pcrProtectionProfileIterator provides a mechanism to perform a depth first traversal of instructions in a PCRProtectionProfile.
type pcrProtectionProfileIterator struct {
	instrs [][]pcrProtectionProfileInstr
}

func (iter *pcrProtectionProfileIterator) descendInToBranches(profiles ...*PCRProtectionProfile) {
	instrs := make([][]pcrProtectionProfileInstr, 0, len(profiles)+len(iter.instrs))
	for _, p := range profiles {
		pi := make([]pcrProtectionProfileInstr, len(p.instrs))
		copy(pi, p.instrs)
		instrs = append(instrs, pi)
	}
	instrs = append(instrs, iter.instrs...)
	iter.instrs = instrs
}

func (iter *pcrProtectionProfileIterator) next() pcrProtectionProfileInstr {
	if len(iter.instrs) == 0 {
		panic("no more instructions")
	}
	if len(iter.instrs[0]) == 0 {
		iter.instrs = iter.instrs[1:]
		return &pcrProtectionProfileEndBranchInstr{}
	}

	instr := iter.instrs[0][0]
	iter.instrs[0] = iter.instrs[0][1:]

	switch i := instr.(type) {
	case *pcrProtectionProfileAddBranchesInstr:
		iter.descendInToBranches(i.profiles...)
	}

	return instr
}

func (iter *pcrProtectionProfileIterator) hasMore() bool {
	return len(iter.instrs) > 0
}

// traverseInstructions returns an iterator that performs a depth first traversal through the instructions in this profile.
func (p *PCRProtectionProfile) traverseInstructions() *pcrProtectionProfileIterator {
	i := &pcrProtectionProfileIterator{}
	i.descendInToBranches(p)
	return i
}

type pcrProtectionProfileStringifyBranchContext struct {
	index int
	total int
}

func (p *PCRProtectionProfile) String() string {
	var b bytes.Buffer

	contexts := []*pcrProtectionProfileStringifyBranchContext{{index: 0, total: 1}}
	profileStart := true

	iter := p.traverseInstructions()
	for iter.hasMore() {
		fmt.Fprintf(&b, "\n")
		depth := len(contexts) - 1
		if profileStart {
			profileStart = false
			fmt.Fprintf(&b, "%*s- Profile %d:\n", depth*3, "", contexts[0].index)
		}

		switch i := iter.next().(type) {
		case *pcrProtectionProfileAddPCRValueInstr:
			fmt.Fprintf(&b, "%*s AddPCRValue(%v, %d, %x)", depth*3, "", i.alg, i.pcr, i.value)
		case *pcrProtectionProfileAddPCRValueFromTPMInstr:
			fmt.Fprintf(&b, "%*s AddPCRValueFromTPM(%v, %d)", depth*3, "", i.alg, i.pcr)
		case *pcrProtectionProfileExtendPCRInstr:
			fmt.Fprintf(&b, "%*s ExtendPCR(%v, %d, %x)", depth*3, "", i.alg, i.pcr, i.value)
		case *pcrProtectionProfileAddBranchesInstr:
			contexts = append([]*pcrProtectionProfileStringifyBranchContext{{index: 0, total: len(i.profiles)}}, contexts...)
			profileStart = true
			fmt.Fprintf(&b, "%*s AddBranches(", depth*3, "")
		case *pcrProtectionProfileEndBranchInstr:
			contexts[0].index++
			if contexts[0].index == contexts[0].total {
				if len(contexts) > 1 {
					fmt.Fprintf(&b, "%*s )", (depth-1)*3, "")
				}
				contexts = contexts[1:]
			} else {
				profileStart = true
			}
		}
	}

	return b.String()
}

// pcrProtectionProfileComputeContext records state used when computing PCR values for a PCRProtectionProfile
type pcrProtectionProfileComputeContext struct {
	parent *pcrProtectionProfileComputeContext
	values pcrValuesList
}

// computePCRValues computes a list of different PCR value combinations from this PCRProtectionProfile.
func (p *PCRProtectionProfile) computePCRValues(tpm *tpm2.TPMContext) (pcrValuesList, error) {
	// Create 2 contexts. The root context is not associated with any profile and exists just to collect PCR values from the root
	// profile.
	var rootContext pcrProtectionProfileComputeContext
	contexts := []*pcrProtectionProfileComputeContext{{parent: &rootContext, values: pcrValuesList{make(tpm2.PCRValues)}}}

	iter := p.traverseInstructions()
	for iter.hasMore() {
		switch i := iter.next().(type) {
		case *pcrProtectionProfileAddPCRValueInstr:
			contexts[0].values.setValue(i.alg, i.pcr, i.value)
		case *pcrProtectionProfileAddPCRValueFromTPMInstr:
			if tpm == nil {
				return nil, fmt.Errorf("cannot read current value of PCR %d from bank %v: no TPM context", i.pcr, i.alg)
			}
			_, v, err := tpm.PCRRead(tpm2.PCRSelectionList{{Hash: i.alg, Select: []int{i.pcr}}})
			if err != nil {
				return nil, xerrors.Errorf("cannot read current value of PCR %d from bank %v: %w", i.pcr, i.alg, err)
			}
			contexts[0].values.setValue(i.alg, i.pcr, v[i.alg][i.pcr])
		case *pcrProtectionProfileExtendPCRInstr:
			contexts[0].values.extendValue(i.alg, i.pcr, i.value)
		case *pcrProtectionProfileAddBranchesInstr:
			// As this is a depth-first traversal, processing of this sequence is parked when an AddBranches instruction is encountered.
			// The next instructions will be from each of the sub-branches, in turn. Create contexts for each of those, initialized with
			// the PCR values computed up to this point.
			var newContexts []*pcrProtectionProfileComputeContext
			for _ = range i.profiles {
				newContexts = append(newContexts, &pcrProtectionProfileComputeContext{parent: contexts[0], values: contexts[0].values.copy()})
			}
			// PCR values computed in each sub-branch are propagated back to us before processing of this sequence resumes, so remove the
			// values computed so far.
			contexts[0].values = nil
			contexts = append(newContexts, contexts...)
		case *pcrProtectionProfileEndBranchInstr:
			// This is the end of this branch - propagate the PCR values computed back to the parent sequence for when processing of it resumes.
			contexts[0].parent.values = append(contexts[0].parent.values, contexts[0].values...)
			contexts = contexts[1:]
		}
	}

	return rootContext.values, nil
}

// computePCRDigests computes a PCR selection and list of PCR digests from this PCRProtectionProfile.
func (p *PCRProtectionProfile) computePCRDigests(tpm *tpm2.TPMContext, alg tpm2.HashAlgorithmId) (tpm2.PCRSelectionList, tpm2.DigestList, error) {
	// Compute the sets of PCR values for all branches
	values, err := p.computePCRValues(tpm)
	if err != nil {
		return nil, nil, err
	}

	// Compute the PCR selection for this profile from the first branch.
	pcrs := values[0].SelectionList()

	// Compute the PCR digests for all branches, making sure that they all contain values for the same sets of PCRs.
	var pcrDigests tpm2.DigestList
	for _, v := range values {
		p, digest, _ := tpm2.ComputePCRDigestSimple(alg, v)
		if !p.Equal(pcrs) {
			return nil, nil, errors.New("not all branches contain values for the same sets of PCRs")
		}
		pcrDigests = append(pcrDigests, digest)
	}

	var filteredPcrDigests tpm2.DigestList
	for _, d := range pcrDigests {
		found := false
		for _, f := range filteredPcrDigests {
			if bytes.Equal(d, f) {
				found = true
				break
			}
		}
		if found {
			continue
		}
		filteredPcrDigests = append(filteredPcrDigests, d)
	}

	return pcrs, filteredPcrDigests, nil
}
